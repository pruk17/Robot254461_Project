sim = require'sim'

-- Threaded Lua mover: animate /IRB4600/IkTarget in WORLD

local tgt

local function setWorldPose(p, eDeg)
    sim.setObjectPosition(tgt, -1, p)
    sim.setObjectOrientation(tgt, -1, {math.rad(eDeg[1]), math.rad(eDeg[2]), math.rad(eDeg[3])})
end

local function lerpPose(p0, e0, p1, e1, dur)
    local dt = math.max(sim.getSimulationTimeStep(), 0.01)
    local steps = math.max(math.floor(dur/dt), 40)
    for k=1,steps do
        local s = k/steps
        local p = { p0[1]+s*(p1[1]-p0[1]), p0[2]+s*(p1[2]-p0[2]), p0[3]+s*(p1[3]-p0[3]) }
        local e = { e0[1]+s*(e1[1]-e0[1]), e0[2]+s*(e1[2]-e0[2]), e0[3]+s*(e1[3]-e0[3]) }
        setWorldPose(p, e)
        sim.step()
    end
end

function sysCall_init()
    tgt = sim.getObject('/IRB4600/IkTarget')
end

function sysCall_thread()
    -- Swirl test
    local baseP = {0.0, 0.0, 0.40}
    local baseE = {0.0, 0.0, 90.0}
    for i=0,59 do
        local ang = (i/60.0)*2.0*math.pi
        setWorldPose({baseP[1]+0.08*math.cos(ang), baseP[2]+0.08*math.sin(ang), baseP[3]}, baseE)
        sim.step()
    end

    -- Task waypoints
    local startP, startE = {0.000,  0.000, 0.0975}, {0.0, 0.0, 90.0}
    local pickP,  pickE  = {2.000,  0.000, 1.600 }, {0.0, 0.0, 90.0}
    local liftP,  liftE  = {2.000,  0.000, 2.600 }, {0.0, 0.0, 90.0}
    local placeP, placeE = {0.000, -1.600, 1.200 }, {0.0, 0.0, 90.0}

    -- Sequence
    lerpPose(startP, startE, startP, startE, 0.2); sim.setInt32Signal('PGripRightAngle_cmd', 0)
    lerpPose(startP, startE, pickP,  pickE,  1.2); sim.setInt32Signal('PGripRightAngle_cmd', 1)
    lerpPose(pickP,  pickE,  liftP,  liftE,  1.0)
    lerpPose(liftP,  liftE,  placeP, placeE, 1.4); sim.setInt32Signal('PGripRightAngle_cmd', 0)
    lerpPose(placeP, placeE, startP, startE, 1.2)

    while true do sim.step() end
end
